Index: apt-cacher2
===================================================================
--- apt-cacher2	(Revision 2104)
+++ apt-cacher2	(Arbeitskopie)
@@ -757,6 +757,9 @@
 
         my $fromfile; # handle for the reader
 
+        my $pid=0;
+        my $doing_download=0;
+
         # download or not decission. Also releases the global lock
         dl_check:
         if( !$force_download && -e $cached_head && -e $cached_file) {
@@ -782,7 +785,8 @@
             &release_global_lock;
         }
         else {
-            # (re) download them
+            # (re) download them, needs to fork the data returning thread while the main thread is doing the download
+            $doing_download=1;
             unlink($cached_file, $cached_head, $complete_file, $notify_file);
             debug_message("file does not exist or so, creating it");
             # Set the status to MISS so the log file can show it had to be downloaded
@@ -792,47 +796,53 @@
             }
 
             # the writer releases the global lock after opening the target file
-            my $pid = fork();
+            $pid = fork();
             if ($pid < 0) {
                 barf("fork() failed");
             }
-            if ($pid == 0) {
-                # child, the fetcher thread
-                undef %childPids;
+            if ($pid != 0) {
+                # parent thread, do the download
+                $childPids{$pid}=1;
                 sysopen($pkfd, $cached_file, O_RDWR|O_CREAT|O_EXCL, 0644) || barf("Unable to store files");
                 open ( $chfd, ">$cached_head");
 
                 if (flock($pkfd, LOCK_EX)) {
 
-                    # release the global lock within fetcher thread after the
+                    # release the global lock within fetching thread after the
                     # file has been created
                     &release_global_lock;
 
                     &fetch_store ($host, $uri); 
 
-                    exit 0;
+                    #exit 0;
                 }
                 else {
                     barf("Problem locking the target file!");
                 }
-                # child exiting above, so or so
             }
-            # parent continues
-            $childPids{$pid}=1;
+            undef %childPids;
             debug_message("registred child process: $pid");
         }
 
+        # return data either in the forked child or in the main thread if not doing download
+        if( !$doing_download || $pid==0) {
+            # the child, does only return data and exit
 
-        &return_file (\$fromfile, $send_head_only);
-        debug_message("Package sent");
+            &return_file (\$fromfile, $send_head_only);
+            debug_message("Package sent");
 
-        # Write all the stuff to the log file
-        writeaccesslog("$cache_status", "$new_filename");
-        if(!check_sum($new_filename)) {
-            writeerrorlog("ALARM! Faulty package in local cache detected! Replacing $new_filename in the next run");
-            unlink $cached_file;
-            exit(4);
+            # Write all the stuff to the log file
+            writeaccesslog("$cache_status", "$new_filename");
+            if(!check_sum($new_filename)) {
+                writeerrorlog("ALARM! Faulty package in local cache detected! Replacing $new_filename in the next run");
+                unlink $cached_file;
+                exit(4);
+            }
         }
+        # if this is a child process, just terminate, otherwise wait for child to finish the data printout
+        exit(0) if($doing_download && $pid==0);
+        wait if($pid != 0); # FIXME, saugt
+ 
     }
 
 }
